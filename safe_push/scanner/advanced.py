import re
from pathlib import Path
from .basic import BasicScanner
from ..patterns_premium import PREMIUM_SECRET_PATTERNS, PREMIUM_EDUCATIONAL_CONTEXT
from ..logger import Logger
import os
import stat

class AdvancedScanner(BasicScanner):
    def __init__(self, root_dir: Path, verbose: bool = False):
        super().__init__(root_dir)
        self.verbose = verbose

    def scan(self):
        # Run basic scan first
        super().scan()
        
        Logger.info("Running advanced premium scan...")
        
        # Additional premium secret scanning
        for path in self.root_dir.iterdir():
            if path.is_file() and self._is_text_file(path):
                if self.verbose:
                    Logger.info(f"Deep scanning {path.name}...")
                self._scan_file_contents(path, PREMIUM_SECRET_PATTERNS)

    def report(self):
        super().report()
        
        # Add premium-specific educational tips
        found_premium = [f for f in self.findings if f.get("pattern_name") in PREMIUM_SECRET_PATTERNS]
        if found_premium:
            Logger.header("Premium Security Insights")
            for item in found_premium:
                p_name = item["pattern_name"]
                # Match pattern name to context (simplified)
                for context_key in PREMIUM_EDUCATIONAL_CONTEXT:
                    if context_key in p_name:
                        Logger.educate(context_key, PREMIUM_EDUCATIONAL_CONTEXT[context_key])
                        break

    def generate_gitignore(self):
        """Premium feature: Generate a recommended .gitignore"""
        gitignore_path = self.root_dir / ".gitignore"
        recommended = [
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            ".env",
            ".venv",
            "venv/",
            "env/",
            "*.swp",
            ".DS_Store"
        ]
        
        if gitignore_path.exists():
            Logger.info(".gitignore already exists. Skipping generation.")
            return

        try:
            with open(gitignore_path, "w") as f:
                f.write("# Recommended .gitignore for Python (generated by safe-push)\n")
                f.write("\n".join(recommended))
                f.write("\n")
            Logger.success("Created a basic .gitignore for you!")
        except Exception as e:
            Logger.error(f"Failed to create .gitignore: {e}")

    def generate_pre_commit_hook(self):
        """Premium feature: Generate a pre-commit hook template"""
        git_dir = self.root_dir / ".git"
        if not git_dir.exists():
            Logger.warning("No .git directory found. Pre-commit hooks require a Git repository.")
            return

        hook_path = git_dir / "hooks" / "pre-commit"
        hook_content = (
            "#!/bin/sh\n"
            "# Pre-commit hook generated by safe-push üõ°Ô∏è\n\n"
            "echo 'Running safe-push security check...'\n"
            "python -m safe_push --verbose\n\n"
            "if [ $? -ne 0 ]; then\n"
            "    echo '‚ùå safe-push found potential leaks! Commit aborted.'\n"
            "    exit 1\n"
            "fi\n\n"
            "echo '‚úÖ No obvious leaks found. Proceeding with commit.'\n"
        )
        try:
            hook_path.parent.mkdir(parents=True, exist_ok=True)
            with open(hook_path, "w") as f:
                f.write(hook_content)
            
            # Make it executable (Unix-like systems)
            st = os.stat(hook_path)
            os.chmod(hook_path, st.st_mode | stat.S_IEXEC)
            
            Logger.success("Pre-commit hook installed! Your commits will now be automatically scanned.")
        except Exception as e:
            Logger.error(f"Failed to create pre-commit hook: {e}")
